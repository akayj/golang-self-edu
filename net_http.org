#+TITLE: Golang 标准库: net/http
#+TAGS: golang, net, http
#+OPTIONS: toc:t author:nil num:2

Golang的标准库之 net/http, http是在编程中出镜率非常高的一个东西。

Golang对它的抽象和封装的学习能让我们更深入了解HTTP并灵活使用它。

* 结构体/接口
** [[https://golang.org/pkg/net/http/#Client][Client]]
*** 方法
- Do(req **Request) (**Response, error)
- Get(url string) (**Response, error)
- Head(req **Request) (**Response, error)
- Post(url, contentType string, body io.Reader) (**Response, error)
- PostForm(url string, data url.Values) (**Response, error)


** [[https://golang.org/pkg/net/http/#Server][Server]]

** [[https://golang.org/pkg/net/http/#Handler][Handler]]
    A handler response to an HTTP request. 处理器响应HTTP请求

#+BEGIN_SRC go :imports "net/http"
type Handler interface {
  ServeHTTP(ResponseWriter, *Request)
}
#+END_SRC

- ServeHTTP 应当将回复的 headers, data 写入 ResponseWriter 然后返回.
- panic(ErrAbortHandler) 让客户端知道回复被中断.

*** FileServer
#+BEGIN_SRC go
func FileServer(root FileSystem) Handler
#+END_SRC

*** NotFoundHandler
#+BEGIN_SRC go
func NotFoundHandler() Handler
#+END_SRC

*** RedirectHandler
#+BEGIN_SRC go
func RedirectHandler(url string, code int) Handler
#+END_SRC

*** TimeoutHandler
#+BEGIN_SRC go
func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler
#+END_SRC

返回一个 Handler h, 它具有时间的限制

*** HandlerFunc
#+BEGIN_SRC go
type HandlerFunc func(ResponseWriter, *Request)
#+END_SRC

HandlerFunc 允许你自定义 HTTP handlers 的一个适配器。
只要函数 f 实现了合适的签名(方法), HandlerFunc(f) 就是一个 Handler。


#+BEGIN_SRC go
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)
#+END_SRC

ServeHTTP 调用 f(w, r)

#+BEGIN_SRC go
package main

import (
  "io"
  "log"
  "net/http"
)

func main() {
  helloHandler := func(w http.ResponseWriter, r *http.Request) {
    io.WriteString(w, "Hello, world!\n")
  }
  http.HandleFunc("/hello", helloHandler)
  log.Fatal(http.ListenAndServe(":8080", nil))
}
#+END_SRC


** [[https://golang.org/pkg/net/http/#Request][Request]]

** Response

** RoundTripper

#+BEGIN_SRC go
  type RoundTripper interface {
    // RoundTrip executes a single HTTP transaction, returning
    // a Response for the provided Request.
    RoundTrip(*Request) (*Response, error)
  }
#+END_SRC

*** NewFileTransport

#+BEGIN_SRC go
func NewFileTransport(fs FileSystem) RoundTripper
#+END_SRC

典型用法:
#+BEGIN_SRC go
t := &http.Transport{}
t.RegisterProtocol("file", http.NewFileTransport(http.Dir("/")))
c := &http.Client{Transport: t}
res, err := c.Get("file:///etc/passwd")
...
#+END_SRC

** Transport

Transport 实现了 RoundTripper, 并支持 HTTP, HTTPS, HTTP代理(HTTP or HTTPS CONNECT)。

默认情况下, Transport缓存连接以供重复使用。

Transport 应当是重复使用，而不是每次都创建, 并且是协程安全的。

#+BEGIN_SRC go
  type Transport struct {

          // If Proxy is nil or returns a nil *URL, no proxy is used.
          Proxy func(*Request) (*url.URL, error)

          // DialContext
          DialContext func(ctx context.Context, network, addr string) (net.Conn, error) // Go 1.7

          // DisableKeepAlives, if true, disables HTTP keep-alives and
          // will only use the connection to the server for a single
          // HTTP Request.
          DisableKeepAlives bool

          // MaxIdleConns controls the max number of idle (keep-alive)
          // connections across all hosts. Zero means no limit.
          MaxIdleConns int  // Go 1.7

          MaxIdleConnsPerHost int

          // MaxResponseHeaderBytes specifies a limit on how many
          // response bytes are allowed in the server's response
          // header.
          MaxResponseHeaderBytes int64
  }

#+END_SRC

方法:

+ func (*Transport) RegisterProtocol(scheme string rt RoundTriper)
+ func (*Transport) RoundTrip(req *Request) (*Response, error)

** Pusher
